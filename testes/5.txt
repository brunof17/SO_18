Vamos la tentar ficheiros grandes a passar pelos nossos pipes
$ cat src/processor.c
>>>

#include "headers/processor.h"

#define READ_SIZE 1024
#define I_MAX_CMD 5
#define I_MAX_BEFORE 5
#define I_MAX_OUT 5


typedef struct command{
    char** lines_before;
    int l_max;
    int l_num; 
    int dep;
    char* command_line;
    char** command;
    char** output_lines;
    int o_max;
    int o_num;
}* Command;


typedef struct notebook{
    Command* commands;
    char* filename;
    int command_max;
    int command_size;
    Buffer file;
    int rollback;
}* Notebook;

Command create_command(){
    Command cmd = malloc(sizeof(struct command));
    cmd->l_max = I_MAX_BEFORE;
    cmd->o_max = I_MAX_OUT;
    cmd->command_line = NULL;
    cmd->command = NULL;
    cmd->dep = -1;
    cmd->lines_before = malloc(sizeof(char *) * (cmd->l_max));
    for(int i = 0 ; i < cmd->l_max ; ++i) cmd->lines_before[i] = NULL;
    cmd->output_lines = malloc(sizeof(char *) * (cmd->o_max));
    for(int i = 0 ; i < cmd->o_max ; ++i) cmd->output_lines[i] = NULL;
    cmd->l_num = 0;
    cmd->o_num = 0;
    return cmd;
}

v
oid update_lines(Command cmd, char* line){
    char** aux;
    if(!cmd) return;
    // realocar o array das linhas
    if((cmd->l_max * 0.8) < cmd->l_num){
        cmd->l_max *= 2;
        aux = realloc(cmd->lines_before, sizeof(char*) * cmd->l_max);
        if(!aux){
            perror("Realloc error");
            _exit(-1);
        }
        cmd->lines_before = aux;
    }
    char* line_cpy = (char*) malloc(strlen(line) + 1);
    line_cpy = strcpy(line_cpy,line);
    cmd->lines_before[cmd->l_num] = line_cpy;
    ++cmd->l_num; 
}

int verify_dependencies(char* command){
    if(command[1] == '|') return 1;
    if(command[1] == ' ') return 0;
    int i;
    for (i = 1 ; command[i] != '|' ; ++i){
        if(!isdigit(command[i]))
            return -1;
    }
    //convert dependency number from string to int
    char* aux = (char*) malloc(i+1);
    aux = strncpy(aux,command+1,i);
    return strtol(aux,NULL,10);
}

void split_command_line(Command cmd){

    char* token, *string, *to_free, *aux;
    char** r_aux;

    int argc = 0, argm = 5, i;

    string = (char*) malloc(strlen(cmd->command_line)+1);
    string = strcpy(string,cmd->command_line);

    cmd->command = malloc(sizeof(char*) * argm);

    if(string){
        to_free = string;
        token = strtok(string," ");
        i = 0;
        while(token !=NULL){
            if(argm * 0.8 < argc){
                argm *= 2;
                r_aux = realloc(cmd->command, sizeof(char*) * argm);
                if(!r_aux){
                    perror("Realloc error on argv");
                    _exit(-1);
                }
                cmd->command = r_aux;
            }
            if(i != 0){
                cmd->command[argc] = (char*) malloc(strlen(token)+1);
                cmd->command[argc] = strcpy(cmd->command[argc],token);
                ++argc;
            }else{
                ++i;
            }
            token = strtok(NULL," ");
        }
        free(to_free);
    }

}

void update_command(Command cmd, char* cmd_str){
    if(!cmd) return;
    cm
d->command_line = (char*) malloc(strlen(cmd_str) +1);
    cmd->command_line = strcpy(cmd->command_line, cmd_str);
    split_command_line(cmd);   
    cmd->dep = verify_dependencies(cmd->command_line); 
}

void update_outputs(Command cmd, char* line, int r){
    if(!cmd) return;

    int size;
    char** r_aux;
    if(cmd->o_max * 0.8 < cmd->o_num){
        cmd->o_max *= 2;
        r_aux = realloc(cmd->output_lines, sizeof(char*) * cmd->o_max);
        if(!r_aux){
            cmd->o_max *= 0.5;
            //TODO CALL ERROR
            return;
        }
        cmd->output_lines = r_aux;
    }
    size = cmd->o_num;
    cmd->output_lines[size] = malloc(strlen(line) +1);
    cmd->output_lines[size] = strncpy(cmd->output_lines[size],line, r);
    ++cmd->o_num;
}

void print_command(Command cmd,int rollback){
    if(!cmd) printf("Error printing command");
    for(int i = 0 ; i < cmd->l_num ; ++i){
        printf("%s\n",cmd->lines_before[i]);
    }
    printf("%s\n",cmd->command_line);
    if(cmd->o_num)  printf("
>>>");
    for(int i = 0; i < cmd->o_num ; ++i){
        printf("\n%s",cmd->output_lines[i]);
    }
    if(cmd->o_num)  printf("<<<\n");
}

void print_notebook(Notebook nb){
    if(!nb) printf("Null notebook, cannot print");
    if(nb->rollback) return;
    for(int i = 0 ; i < nb->command_size ; ++i ){
        print_command(nb->commands[i],nb->rollback);  
    }
}

Notebook create_notebook(char* filename){
    int nb_fd = open(filename, O_RDONLY);
    if(nb_fd < 0){
        perror("Erro na abertura do ficheiro");
        _exit(-1);    
    }
    Notebook nb = (Notebook) malloc(sizeof(struct notebook));
    nb->command_max = I_MAX_CMD;
    nb->command_size = 0;
    nb->commands = malloc(sizeof(Command)*5);
    nb->file = create_buffer(nb_fd,READ_SIZE);
    nb->filename = (char*)  malloc(strlen(filename)+1);
    nb->filename = strcpy(nb->filename, filename);
    nb->rollback = FALSE;
    return nb;
}

void populate_notebook(Notebook nb){
    if(!nb){
        printf("Notebook not defined\n");
        return;
   
 }
    char buf[1024] = {0};
    int r;
    int prev_out = FALSE;
    nb->commands[nb->command_size] = create_command(); 

    //TODO falta resize do array dos Command
    //TODO falta verificar se o ficheiro tem os >>> <<< e ignorar texto entre estes
    while(1){
        r = readln(nb->file,buf,1024);
        if ( r == 0) break;

        // quando encontrar uma linha que começe por $, adicionar ao commando, e depois passar para o proximo "commando"
        if(buf[0] == '>'){
            prev_out = TRUE;
        }
        if(buf[0] == '$'){
            update_command(nb->commands[nb->command_size],buf);
            ++nb->command_size;
            nb->commands[nb->command_size] = create_command();
        }else if(!prev_out){
            update_lines(nb->commands[nb->command_size],buf);
        }  
        if(buf[0] == '<'){
            prev_out = FALSE;
        }

    }
}

int exec_cmd(Command cmd, Command dep){
    int status;
    int r = 0;

    int pd_in[2], pd_out[2];
    char buf[1024];
    
    if(pip
e(pd_in) == -1) perror("Error on pipe creation (in)");
    if(pipe(pd_out) == -1) perror("Error on pipe creation (out)");

    if(fork() == 0){
        //Fechar escrita do pipe in
        close(pd_in[1]);
        if(dep != NULL){
            //Duplicar leitura do pipe in como stdin
            dup2(pd_in[0],0);
        }
        //Fechar entrada do pipe in
        close(pd_in[0]);


        //Fechar a leitura do pipe out
        close(pd_out[0]);
        //Duplicar a escrita do pipe como stdout
        dup2(pd_out[1],1);
        //Fechar a escrita do pipe
        close(pd_out[1]);
        
        r = execvp(cmd->command[0],cmd->command);
        printf("Command %s\n",cmd->command_line);
        perror("Erro no exec");
        _exit(r);

    }else{
        close(pd_in[0]);
        if(dep && dep->output_lines){
            for(int i = 0 ; dep->output_lines[i] != NULL ; ++i){
                write(pd_in[1],dep->output_lines[i], strlen(dep->output_lines[i]));
            }
        }
        close(pd_in[1]);
    
    
        wait(&status);
        close(pd_out[1]);
        if(WIFEXITED(status) && WEXITSTATUS(status)== 0){
            while((r = read(pd_out[0],buf,1024))){
                if(r <= 0) break;
                buf[r] = '\0';
                update_outputs(cmd, buf, r);
            }
        }else{
            while((r = read(pd_out[0], buf, 1024))){
                if(r <= 0) break;
                buf[r] = '\0';
                printf("%s\n",buf);
            }
            return FALSE;
        }
        close(pd_out[0]);
    }
    return TRUE;
}


void start_exec(Notebook nb){
    int dep;
    Command prev = NULL;
    if(!nb){
        perror("Notebook not existant");
        return;
    }

    for(int i = 0 ; i < nb->command_size ; ++i){
        dep = nb->commands[i]->dep;
        // dependencies:
        ////        pipe(pd);
        if(dep == -1) { perror("Erro nas dependencias");
        }
        if(dep != 0){
            // check bondaries
            if( i >= dep ? TRUE : FALSE){
                //
Get output from previous as input for the pipe
                prev = nb->commands[i-dep];
            }else{
                nb->rollback = TRUE;
                //TODO rollbackFile()
                break;
            } 
        }

        if(!exec_cmd(nb->commands[i],prev)){
            nb->rollback = TRUE;
            break;
        }
    }    
}

void write_command(Command cmd, int fd){

    for(int i = 0 ; i < cmd->l_num ; ++i){
        write(fd, cmd->lines_before[i], strlen(cmd->lines_before[i]));
        write(fd, "\n", 1);
    }

    write(fd, cmd->command_line, strlen(cmd->command_line));
    write(fd, "\n", 1);

    if(cmd->o_num) write(fd, ">>>", 3);

    for(int i = 0 ; i < cmd->o_num ; ++i){
        write(fd, "\n", 1);
        write(fd, cmd->output_lines[i], strlen(cmd->output_lines[i]));
    }
        
    if(cmd->o_num){
        write(fd, "<<<", 3);
        write(fd, "\n", 1);
    }

    
}

void override_file(Notebook nb){
    
    if(!nb) return;
    if(nb->rollback) return;
    int fd = ope
n(nb->filename, O_WRONLY | O_TRUNC);
    for(int i = 0 ; i < nb->command_size ; ++i){
        write_command(nb->commands[i],fd);
    }

}

int main(int argc, char** argv) {

    if(argc < 2){
        printf("Usage: ./processor <filename>\n");
        _exit(-1);
    }

    //  Create notebook with the corresponding file
    Notebook nb = create_notebook(argv[1]);


    //Populate struct with notebook informations
    populate_notebook(nb);
    //    printf("ANTES EXEC!!!:%s\n",nb->commands[1]->command[0]);

    // Close file, by getting the file descriptor from the buffer_t struct
    int fd = get_fildes(nb->file); 
    close(fd);

//    print_notebook(nb);

    // Reopen file for writing
    start_exec(nb);
    // Exec commands and write outputs
    print_notebook(nb);
    
    override_file(nb);
    
    close(fd);    

    return 0;
}
<<<
E agora vamos tentar ordenar isto
$| sort
>>>




















































    
    
    
    
    
        
        
        
                }
            }
            }
            }
            }
            }
            } 
        }
        }
        }
        }
        }
        }
        }
        }
        }
        }
        }
        }  
    }
    }
    }
    }
    }
    }
    }
    }
    }
    }
    }
    }
    }
    }
    }
    }
    }
    }    
}
}
}
}
}
}
}
}
}
}
}
}
}
}
}
                ++argc;
                argm *= 2;
        aux = realloc(cmd->lines_before, sizeof(char*) * cmd->l_max);
    aux = strncpy(aux,command+1,i);
                break;
            break;
    Buffer file;
                buf[r] = '\0';
                buf[r] = '\0';
    char** aux;
    char* aux = (char*) malloc(i+1);
    char buf[1024];
    char buf[1024] = {0};
    char** command;
    char* command_line;
    char* filename;
    char* line_cpy = (char*) malloc(strlen(line) + 1);
    char** lines_before;
    char** output_lines;
    cha
r** r_aux;
    char** r_aux;
    char* token, *string, *to_free, *aux;
            // check bondaries
    close(fd);
    close(fd);    
    // Close file, by getting the file descriptor from the buffer_t struct
        close(pd_in[0]);
        close(pd_in[0]);
        close(pd_in[1]);
        close(pd_in[1]);
        close(pd_out[0]);
        close(pd_out[0]);
        close(pd_out[1]);
        close(pd_out[1]);
                cmd->command[argc] = (char*) malloc(strlen(token)+1);
                cmd->command[argc] = strcpy(cmd->command[argc],token);
    cmd->command_line = (char*) malloc(strlen(cmd_str) +1);
    cmd->command_line = NULL;
    cmd->command_line = strcpy(cmd->command_line, cmd_str);
    cmd->command = malloc(sizeof(char*) * argm);
    cmd->command = NULL;
                cmd->command = r_aux;
    cmd->dep = -1;
    cmd->dep = verify_dependencies(cmd->command_line); 
        cmd->lines_before = aux;
    cmd->lines_before[cmd->l_num] = line_cpy;
    cmd->lines_before = malloc(sizeof(char *) * (cmd
->l_max));
        cmd->l_max *= 2;
    cmd->l_max = I_MAX_BEFORE;
    ++cmd->l_num; 
    cmd->l_num = 0;
            cmd->o_max *= 0.5;
        cmd->o_max *= 2;
    cmd->o_max = I_MAX_OUT;
    ++cmd->o_num;
    cmd->o_num = 0;
    cmd->output_lines = malloc(sizeof(char *) * (cmd->o_max));
        cmd->output_lines = r_aux;
    cmd->output_lines[size] = malloc(strlen(line) +1);
    cmd->output_lines[size] = strncpy(cmd->output_lines[size],line, r);
}* Command;
    Command cmd = malloc(sizeof(struct command));
    Command* commands;
Command create_command(){
    Command prev = NULL;
    //convert dependency number from string to int
    //  Create notebook with the corresponding file
#define I_MAX_BEFORE 5
#define I_MAX_CMD 5
#define I_MAX_OUT 5
#define READ_SIZE 1024
        // dependencies:
        dep = nb->commands[i]->dep;
            dup2(pd_in[0],0);
        dup2(pd_out[1],1);
        //Duplicar a escrita do pipe como stdout
            //Duplicar leitura do pipe in como stdin
            }else{
       
     }else{
        }else{
    }else{
        }else if(!prev_out){
    // Exec commands and write outputs
                    _exit(-1);
            _exit(-1);
        _exit(-1);
        _exit(-1);    
        _exit(r);
        //Fechar a escrita do pipe
        //Fechar a leitura do pipe out
        //Fechar entrada do pipe in
        //Fechar escrita do pipe in
    for (i = 1 ; command[i] != '|' ; ++i){
            for(int i = 0 ; dep->output_lines[i] != NULL ; ++i){
    for(int i = 0 ; i < cmd->l_max ; ++i) cmd->lines_before[i] = NULL;
    for(int i = 0 ; i < cmd->l_num ; ++i){
    for(int i = 0 ; i < cmd->l_num ; ++i){
    for(int i = 0 ; i < cmd->o_max ; ++i) cmd->output_lines[i] = NULL;
    for(int i = 0 ; i < cmd->o_num ; ++i){
    for(int i = 0; i < cmd->o_num ; ++i){
    for(int i = 0 ; i < nb->command_size ; ++i ){
    for(int i = 0 ; i < nb->command_size ; ++i){
    for(int i = 0 ; i < nb->command_size ; ++i){
        free(to_free);
                //Get output from previous as input for the pipe
 
               ++i;
        i = 0;
    if(argc < 2){
            if(argm * 0.8 < argc){
        if(!aux){
        if(buf[0] == '<'){
        if(buf[0] == '>'){
        if(buf[0] == '$'){
    if((cmd->l_max * 0.8) < cmd->l_num){
    if(cmd->o_max * 0.8 < cmd->o_num){
    if(cmd->o_num){
    if(cmd->o_num)  printf(">>>");
    if(cmd->o_num)  printf("<<<\n");
    if(cmd->o_num) write(fd, ">>>", 3);
    if(!cmd) printf("Error printing command");
    if(!cmd) return;
    if(!cmd) return;
    if(!cmd) return;
    if(command[1] == ' ') return 0;
    if(command[1] == '|') return 1;
        if(dep != 0){
        if(dep == -1) { perror("Erro nas dependencias");
        if(dep && dep->output_lines){
        if(dep != NULL){
        if(!exec_cmd(nb->commands[i],prev)){
    if(fork() == 0){
            if(i != 0){
            if( i >= dep ? TRUE : FALSE){
        if(!isdigit(command[i]))
    if(!nb){
    if(!nb){
    if(nb_fd < 0){
    if(!nb) printf("Null notebook, cannot print");
    if(!nb) return;
    if(nb->rollback)
 return;
    if(nb->rollback) return;
    if(pipe(pd_in) == -1) perror("Error on pipe creation (in)");
    if(pipe(pd_out) == -1) perror("Error on pipe creation (out)");
                if(r <= 0) break;
                if(r <= 0) break;
        if ( r == 0) break;
                if(!r_aux){
        if(!r_aux){
    if(string){
        if(WIFEXITED(status) && WEXITSTATUS(status)== 0){
#include "headers/processor.h"
    int argc = 0, argm = 5, i;
    int command_max;
    int command_size;
    int dep;
    int dep;
int exec_cmd(Command cmd, Command dep){
    int fd = get_fildes(nb->file); 
    int fd = open(nb->filename, O_WRONLY | O_TRUNC);
    int i;
    int l_max;
    int l_num; 
int main(int argc, char** argv) {
    int nb_fd = open(filename, O_RDONLY);
    int o_max;
    int o_num;
    int pd_in[2], pd_out[2];
    int prev_out = FALSE;
    int r;
    int r = 0;
    int rollback;
    int size;
    int status;
int verify_dependencies(char* command){
    line_cpy = strcpy(line_cpy,line);
    nb->command_max =
 I_MAX_CMD;
            ++nb->command_size;
    nb->command_size = 0;
    nb->commands = malloc(sizeof(Command)*5);
            nb->commands[nb->command_size] = create_command();
    nb->commands[nb->command_size] = create_command(); 
    nb->file = create_buffer(nb_fd,READ_SIZE);
    nb->filename = (char*)  malloc(strlen(filename)+1);
    nb->filename = strcpy(nb->filename, filename);
    nb->rollback = FALSE;
                nb->rollback = TRUE;
            nb->rollback = TRUE;
}* Notebook;
Notebook create_notebook(char* filename){
    Notebook nb = create_notebook(argv[1]);
    Notebook nb = (Notebook) malloc(sizeof(struct notebook));
    override_file(nb);
        perror("Erro na abertura do ficheiro");
        perror("Erro no exec");
        perror("Notebook not existant");
            perror("Realloc error");
                    perror("Realloc error on argv");
        ////        pipe(pd);
    populate_notebook(nb);
    //Populate struct with notebook informations
                prev = nb->commands[i-
dep];
            prev_out = FALSE;
            prev_out = TRUE;
        print_command(nb->commands[i],nb->rollback);  
    //    printf("ANTES EXEC!!!:%s\n",nb->commands[1]->command[0]);
        printf("Command %s\n",cmd->command_line);
        printf("Notebook not defined\n");
        printf("\n%s",cmd->output_lines[i]);
                printf("%s\n",buf);
    printf("%s\n",cmd->command_line);
        printf("%s\n",cmd->lines_before[i]);
        printf("Usage: ./processor <filename>\n");
    print_notebook(nb);
//    print_notebook(nb);
        // quando encontrar uma linha que começe por $, adicionar ao commando, e depois passar para o proximo "commando"
                r_aux = realloc(cmd->command, sizeof(char*) * argm);
        r_aux = realloc(cmd->output_lines, sizeof(char*) * cmd->o_max);
    // realocar o array das linhas
    // Reopen file for writing
            return;
        return;
        return;
    return 0;
            return -1;
    return cmd;
            return FALSE;
    return nb;
    
return strtol(aux,NULL,10);
    return TRUE;
        r = execvp(cmd->command[0],cmd->command);
        r = readln(nb->file,buf,1024);
    size = cmd->o_num;
    split_command_line(cmd);   
    start_exec(nb);
    string = (char*) malloc(strlen(cmd->command_line)+1);
    string = strcpy(string,cmd->command_line);
            //TODO CALL ERROR
    //TODO falta resize do array dos Command
    //TODO falta verificar se o ficheiro tem os >>> <<< e ignorar texto entre estes
                //TODO rollbackFile()
        to_free = string;
            token = strtok(NULL," ");
        token = strtok(string," ");
typedef struct command{
typedef struct notebook{
            update_command(nb->commands[nb->command_size],buf);
            update_lines(nb->commands[nb->command_size],buf);
                update_outputs(cmd, buf, r);
void override_file(Notebook nb){
void populate_notebook(Notebook nb){
void print_command(Command cmd,int rollback){
void print_notebook(Notebook nb){
void split_command_line(Command cmd){
void 
start_exec(Notebook nb){
void update_command(Command cmd, char* cmd_str){
void update_lines(Command cmd, char* line){
void update_outputs(Command cmd, char* line, int r){
void write_command(Command cmd, int fd){
        wait(&status);
    while(1){
            while((r = read(pd_out[0], buf, 1024))){
            while((r = read(pd_out[0],buf,1024))){
        while(token !=NULL){
        write_command(nb->commands[i],fd);
        write(fd, "<<<", 3);
    write(fd, cmd->command_line, strlen(cmd->command_line));
        write(fd, cmd->lines_before[i], strlen(cmd->lines_before[i]));
        write(fd, cmd->output_lines[i], strlen(cmd->output_lines[i]));
        write(fd, "\n", 1);
        write(fd, "\n", 1);
        write(fd, "\n", 1);
    write(fd, "\n", 1);
                write(pd_in[1],dep->output_lines[i], strlen(dep->output_lines[i]));
<<<
